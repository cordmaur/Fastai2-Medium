// Compute the linear regression manually
function linearRegression(x, y) {
    const n = x.length;
    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

    for (let i = 0; i < n; i++) {
        sumX += x[i];
        sumY += y[i];
        sumXY += x[i] * y[i];
        sumX2 += x[i] * x[i];
    }

    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;

    return { slope, intercept };
}

function checkboxChanged(event) {
    // The easiest way here is to always copy the specific rows from the original array
    let data = []
    const checkedCheckboxes = document.querySelectorAll('input[type="checkbox"]:checked');

    checkedCheckboxes.forEach(checkbox => {
        const idx = checkbox.value
        // push this row to data
        data.push(originalData[idx])
    })

    plotChart(data)
}

// Function to create checkboxes
function createCheckboxes(data) {
    checkboxContainer.innerHTML = ''

    data.forEach((item, index) => {
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `checkbox-${item['idx']}`;
        checkbox.name = item['Data Evento'];
        checkbox.value = index;
        checkbox.checked = true
        checkbox.setAttribute('data-group', 'station')
        const label = document.createElement('label');
        label.htmlFor = `checkbox-${item['idx']}`;

        const label_text = `${item['idx']}: ${item['Data Evento']} - ${item['Tipologia']}`
        label.appendChild(document.createTextNode(label_text));

        const br = document.createElement('br');

        checkbox.addEventListener('change', checkboxChanged)

        checkboxContainer.appendChild(checkbox);
        checkboxContainer.appendChild(label);
        checkboxContainer.appendChild(br);
    });
}

function plotChart2(data) {
    // Create the Plotly Chart

    // First, plot the original scatter (unselected)

    const originalScatter = {
        x: originalData.map(row => row['TR lognorm']),
        y: originalData.map(row => row['Danos Humanos']),
        text: originalData.map(row => row['idx']),
        mode: 'markers+text',
        type: 'scatter',
        name: 'Desastres',
        textposition: 'top center',
        marker: {
            size: 7,
            opacity: 0.6
        }
    }

    // Create the data for the plot
    x = data.map(row => row['TR lognorm'])
    y = data.map(row => row['Danos Humanos'])
    const traceScatter = {
        x: x,
        y: y,
        text: data.map(row => row['Data Evento']),
        mode: 'markers',
        type: 'scatter',
        name: 'Desastres - Selecionados',
        marker: {
            size: 10,
            color: data.map(row => row['Tipologia'] === 'Enxurradas' ? 'blue' : 'red')
        }
    }

    const { slope, intercept } = linearRegression(x, y);
    // Generate x values for the regression line
    const xValues = [Math.min(...x), Math.max(...x), 25];
    const yValues = xValues.map(x => slope * x + intercept);

    // Create the data for the regression line
    const traceRegression = {
        x: xValues,
        y: yValues,
        mode: 'lines',
        type: 'scatter',
        name: 'Regressao Linear',
        line: {
            color: 'red',
            width: 2,
            dash: 'dash'
        }
    };

    // Create the layout
    const layout = {
        title: `Estação: ${data[0]['Código']} - População: ${data[0]['População']}`,
        xaxis: { title: 'Tempo de Retorno (Anos)' },
        yaxis: { title: 'Danos Humanos' }
    }

    // Get the element where to plot to
    Plotly.newPlot('chart', [originalScatter, traceScatter, traceRegression], layout)
}

function createScatter(data, name, marker) {
    // Create the data for the plot
    const scatter = {
        x: data.map(row => row['TR lognorm']),
        y: data.map(row => row['Danos Humanos']),
        text: data.map(row => row['idx']),
        mode: 'markers+text',
        type: 'scatter',
        name: name,
        textposition: 'top center',
        marker: marker
    }

    return scatter
}

function plotChart(data) {
    // Create the Plotly Chart

    // First, create the "enxurradas" (FlashFloods)
    filteredData = originalData.filter(item => item['Tipologia'] === 'Enxurradas')
    ffScatter = createScatter(
        filteredData,
        'Enxurradas',
        { size: 10, opacity: .6, color: 'blue', symbol: 'diamond' }
    )

    // Then, create the floods
    filteredData = originalData.filter(item => item['Tipologia'] === 'Inundações')
    floodScatter = createScatter(
        filteredData,
        'Inundações',
        { size: 10, opacity: .6, color: 'orange', symbol: 'circle' }
    )


    // Create the selected plots
    x = data.map(row => row['TR lognorm'])
    y = data.map(row => row['Danos Humanos'])
    const selectedScatter = {
        x: x,
        y: y,
        text: data.map(row => row['Data Evento']),
        mode: 'markers',
        type: 'scatter',
        name: 'Selecionados',
        marker: {
            size: 15, opacity: 1., symbol: 'circle-open', line: {
                color: 'red',  // Outline color
                width: 2  // Outline width
            }
        }
    }


    // // Create the data for the plot


    const { slope, intercept } = linearRegression(x, y);
    // Generate x values for the regression line
    const xValues = [Math.min(...x), Math.max(...x), 25];
    const yValues = xValues.map(x => slope * x + intercept);

    // Create the data for the regression line
    const traceRegression = {
        x: xValues,
        y: yValues,
        mode: 'lines',
        type: 'scatter',
        name: 'Regressao Linear',
        line: {
            color: 'red',
            width: 2,
            dash: 'dash'
        }
    };

    // Create the layout
    const layout = {
        title: `Estação: ${originalData[0]['Código']} - População: ${originalData[0]['População']}`,
        xaxis: { title: 'Tempo de Retorno (Anos)' },
        yaxis: { title: 'Danos Humanos' }
    }

    // Get the element where to plot to
    Plotly.newPlot('chart', [ffScatter, floodScatter, selectedScatter, traceRegression], layout)
}

async function fetchFile(url) {
    try {
        const response = await fetch(url)
        const txt = await response.text()
        return txt
    } catch (error) {
        console.error('Error fetching CSV file:', error)
    }
}

function toggleSection(sectionId) {
    section = document.getElementById(sectionId);
    var arrow = section.previousElementSibling.querySelector('.arrow');

    // Toggle the hidden style and get the status 
    let hidden = section.classList.toggle('section-hidden')

    // Adjust the arrow accordingly
    if (hidden) {
        arrow.classList.remove('down')
    } else {
        arrow.classList.add('down')
    }
}

function loadDisastersApp(cityName) {
    // fetch the station information from a url
    csvUrl = IO.rawUrl + `/${cityName}/disasters_risk.csv`

    fetchFile(csvUrl).then(csvData => {
        console.log(csvData)
        // Load the file with the data
        originalData = Papa.parse(csvData, {
            header: true,
            dynamicTyping: true,
        }
        ).data

        // Remove the last element
        originalData.pop()

        // Add an index for each row
        originalData.forEach((row, idx) => {
            row['idx'] = idx
        })

        // Create the checkboxes
        createCheckboxes(originalData)

        // Plot initial Chart
        plotChart(originalData)

    })
}

function loadReport(cityName) {
    console.log(cityName)

    // fetch the station information from a url
    reportUrl = IO.rawUrl + `/${cityName}/Report_${cityName}.html`

    fetch(reportUrl)
        .then(response => response.text())
        .then(data => {
            document.getElementById('content').innerHTML = data
        })
        .catch(error => console.error('Error fetching report:', error))
}

function updateCity(cityName) {
    loadDisastersApp(cityName)
    loadReport(cityName)
}

function stationChanged(event) {
    console.log(event.target.checked)

    el = document.getElementById('correctStation')
    el.disabled = !event.target.checked

}

// Function to convert an array of objects to CSV
function arrayToCSV(data) {
    const csvRows = [];
    // Get headers
    const headers = Object.keys(data[0]);
    csvRows.push(headers.join(','));

    // Loop over the rows
    for (const row of data) {
        const values = headers.map(header => {
            const val = row[header];
            // Handle null and undefined values
            return val === null || val === undefined ? '' : val;
        });
        csvRows.push(values.join(','));
    }

    return csvRows.join('\n');
}

function getSelectedData() {
    const data = {}

    // Load selected disasters
    const disasters = []
    const checkedCheckboxes = document.querySelectorAll('input[data-group="station"]:checked');

    checkedCheckboxes.forEach(checkbox => {
        const idx = checkbox.value
        // push this row to data
        disasters.push(originalData[idx])
    })
    data['Desastres'] = disasters

    // get other information
    data['Analisada'] = !document.getElementById('cityAnalysis').checked

    data['EstaçãoErrada'] = document.getElementById('incorrectStation').checked
    if (data['EstaçãoErrada']) {
        data['EstaçãoCorreta'] = document.getElementById('correctStation').value
    } else {
        data['EstaçãoCorreta'] = originalData[0]['Código']
    }

    data['Observações'] = document.getElementById('observations').value

    // console.log(data)

    return data
}